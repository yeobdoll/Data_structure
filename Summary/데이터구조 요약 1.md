# 데이터 구조 요약 1

## 시간 복잡도
- 알고리즘이 실행되는 동안에 사용된 기본적인 연산 횟수를 입력 크기의 함수로 나타냄.
- 빅오 표기법 EX
  1. print -> O(1)
  2. for -> O(n)
  3. 이중 for -> O(n^2)
  4. while -> O(lg n)
  5. for문 안에 while -> O(n lg n)
- 당연히 Big O-notation은 **최악의 경우(worst case)이다.** 예로들어 O(n^2)를 말하자면 알고리즘이 **기껏해야** n^2에 비례하는 시간이 든다는 것이다.
- 빅오메가는 최선의 경우(best case)이다. 알고리즘이 **적어도** n^2에 비례하는 시간이 든다는 것이다.
- 빅세타는 평균의 경우(average case)이다. 알고리즘이 **항상** n^2에 비례하는 시간이 든다는 것이다.
  
- 일반적으로 알고리즘의 수행시간은 최악 경우 분석으로 표현한다!

## 순환 알고리즘
- 알고리즘이나 함수가 수행 도중에 자기 자신을 다시 호출하여 문제를 해결하는 기법
- 대부분의 순환은 반복으로 바꾸어 작성 가능
  1. 팩토리얼 구하기 -> 순환 구조: O(n), 반복 구조: O(n)
  2. 피보나치 수열(순환이 느린 예) -> 순환: O(2^n), 반복: O(n)
  3. 순환적인 거듭제곱 함수 -> 순환: O(lg n), 반복: O(n)
  4. 이항 계수, 하노이의 탑, 이진 탐색 등

## 리스트
- 항목들이 순서대로 나열되어 있고, 각 항목들은 위치를 갖음.
- Stack, Queue, Deque과의 차이점
  - 자료의 접근 위치 
  - 리스트의 기능을 제한
> **리스트 구현 방법**
  - 배열 구조
    1. 구현이 간단
    2. 항목 접근이 O(1)
    3. 삽입, 삭제시 오버헤드
    4. 항목의 개수 제한
  - 연결된 구조
    1. 구현이 복잡
    2. 항목 접근이 O(n)
    3. 삽입, 삭제가 효율적
    4. 크기가 제한되지 않음

## 파이썬 리스트 
1. 배열구조이다! 
2. 스마트한 배열! (스마트: 용량을 늘릴 수 있음)
3. 동적 배열로 구현됨 (필요한 양보다 넉넉한 크기의 메모리 사용)
4. 남은 공간이 없으면 어떻게든 용량 증가 가능하긴함. 근데 메모리의 낭비는 감수해야함. 튜플은 변경없이 메모리 면에서는 효율적이다.
  - append(): 대부분 O(1).. 용량 넘치면 O(n) 그래도 효율적임
  - insert(): O(n)
  - pop(): O(n)
  
- BFS: 출발점에서부터 인점 위치들을 먼저 방문한 다음, 방문한 위치들에 인접한 위치들을 순서대로 찾아가는 방법
  
## 스택의 용도 (LIFO: 후입선출)
- 깊이 우선 탐색: 하나의 경로를 선택해 끝까지 가보고 막히면 가장 최근 경로 시도
- 가장 최근에 들어온 데이터가 가장 먼저 나감
> 리스트와 스택의 차이점
  - 이 녀석은 리스트와 다르게 삽입/삭제 할 때 리스트의 맨 뒤를 공략함. 왜냐하면 리스트처럼 앞에다 삽입한다고 치자. 그러면 많은 항목들의 이동이 필요하다.. 그러므로 비효율적 O(n)이다. 하지만!! Stack같은 경우는 맨 뒤를 공략하니깐 바로 추가하거나 삭제 가능!! O(1)임!
- 스택이 2개일 때는 전역변수 top[]이 1개이기 때문에 사용 못함.. 그래서 클래스를 활용한다!
> 스택의 용도
  1. 되돌리기 (이전 페이지 이동)
  2. 함수호출
  3. 괄호검사
    1. 열린 괄호 나오면 스택에 삽입
    2. 닫힌 괄호 나오면 스택에서 빼내어 비교함
  4. 수식의 계산 (계산기)
    - 수식 계산 과정은 중위 -> 후위 변환하여 후위로 계산한다.
    - 왜냐하면!! **괄호 X, 우선순위 X, 읽으면서 바로 계산이 가능하기 때문!!!**
    > 예시
      1. A+B -> AB+
      2. 5+AxB -> 5ABx+
      3. (A+B)xC -> AB+Cx
      4. 2+3x4 -> 234x+
      5. (9-(4/2+1))x(5x2-2) -> 942/1+-52x2-x
      6. a = (b-c)xd+e -> abc-dxe+=
  5. 미로탐색
  
## 큐의 용도 (FIFO:선입선출)
- 너비 우선 탐색: 가까운 위치부터 차근차근 찾아가는 전략
- 삭제는 전단에서만! 삽입은 후단에서만! (현실에 줄 기다리는거 생각하면 됨)
- 선형 큐는 비효율적. -> 삽입:O(1), 삭제:O(n).. 리스트와 같은 단점 발생
- 그러므로 배열을 원형으로 사용하는 원형 큐가 훨씬 효율적.
- **원형 큐의 개념은 꼭 공부하도록 하자!!**
  - https://lktprogrammer.tistory.com/59 참고하라
  1. 삽입: rear를 하나 증가 시키고 그 위치에 삽입함
  2. 삭제: front를 하나 증가 시키고 그 위치 항목 반환
  3. 공백상태: front == rear
  4. 포화상태: front == (rear+1) % M
  5. 원형 큐는 하나의 공간은 항상 비워둔다. -> 배열의 포화상태 여부를 판단하기 위함.
> 큐의 응용
  1. 서비스센터의 콜
  2. 프린터와 컴퓨터 사이의 인쇄 작업 (버퍼링)
  3. 실시간 비디오 스트리밍에서의 버퍼링
  4. 시뮬레이션의 대기열
  5. 통신에서의 데이터 패킷들의 모델링에 이용
  
## 덱은 스택이나 큐보다는 입출력이 자유로운 자료구조이다
- 덱 (front와 rear에서 모두 삽입과 삭제가 가능한 큐)
  1. 덱에서는 삽입과 삭제를 양쪽 모두 가능
  2. 그러나 여전히 중간에 넣거나 빼지는 못함
  3. 큐, 스택과 비슷한 연산들이 많다
- 원형 덱의 연산은 큐와 데이터는 동일하고 연산 또한 유사하다. 차이점은 3개 정도 추가된 연산자가 있음. 반 시계방향 회전 필요
1. 컴퓨터나 핸드폰의 화면을 위로 올리거나 아래로 내리는 스크롤 처리 (덱)
  
## 우선순위 큐
1. 도로에서의 자동차 우선순위
2. 우선순위의 개념을 큐에 도입한 자료구조
3. 모든 데이터가 우선 순위 가짐
4. 입력 순서와 상관없이 우선 순위가 높은 데이터가 먼저 출력
5. 가장 일반적인 큐로 볼 수있음.
- 응용 분야
  1. 시뮬레이션
  2. 네크워크 트래픽 제어
  3. OS의 작업 스케쥴링 등  
-------------------------------------------------
## 배열 구조 vs 연결된 구조
> **배열 구조**
  1. 구현 간단
  2. 항목 접근 O(1)
  3. 삽입, 삭제시 오버헤드
  4. 항목의 개수 제한
> **연결된 구조**
  1. 구현 복잡
  2. 항목 접근 O(n)
  3. 삽입, 삭제가 효율적
  4. 크기 제한 X
  - 연결 리스트 구조: 흩어진 데이터를 링크로 연결해서 관리
    1. 노드
      - 데이터 필드
      - 하나 이상의 링크 필드 (가리키는 노드의 주소 저장변수)
    2. 헤드 포인터
      - 첫번째 노드만 알면 링크로 모든 노드에 순차 접근.. 따라서 시작 노드 주소를 헤드 포인터에 저장
  - 종류
    1. 단순 연결 리스트(singly linked list)
      - 응용: 연결된 스택 구현
      - 응용: 연결된 리스트 구현(LinkedList)
    2. 원형 연결 리스트(circular linked list)
      - **단순연결리스트로 구현한 큐보다 원형연결리스트로 구현한 큐가 더 효율적이다. 왜냐하면 tail을 사용하는 것이 rear와 front에 바로 접근할 수 있다는 점에서 훨씬 효율적이기 때문이다.**
      - 응용: 연결된 큐 구현.. 용량 제한X, 삽입/삭제가 모두 O(1)
    3. 이중 연결 리스트(doubly linked list)
      - 응용: 연결된 덱 구현
  - **단순 연결 리스트로 구현한 덱은 deleteRear()을 하여 후단을 삭제하고 나면 rear를 앞으로 한 칸 옮겨야 하는데, rear의 선행 노드를 바로 알 수가 없다..(정보가 없음) 그래서 front부터 시작하여 선행노드를 찾아야함.. 여기서 시간복잡도는 O(n)이다. 이를 해결하기 위해 이중연결리스트가 등장함.**
  - **이중연결리스트는 선행 노드를 가리키는 링크가 있음. 그래서 선행 노드를 쉽게 찾아갈 수 있음.**
  
  - 이중연결리스트는 데이터 접근이 용이해진다. 단점은 윗 연결 리스트보다 복잡하고 연결을 하나씩 더 먹어서 공간도 그만큼 더 차지함.
  - 연결리스트는 노드의 삽입/삭제는 자유롭지만 검색에는 취약함! 알고 있겠지만 이것이 배열리스트와 차이점 중 하나임. 즉, 뭔가 자주 빠지고 추가가 되지만 검색 빈도는 낮은 부분에 쓰인다!!!! 뭐 예를 들면 서점에서 도서가 들어오고 나가는 프로그램에는 연결 리스트가 유용하게 쓰일 것이다.
